# Основы CSS

CSS (Cascade Style Sheets) - каскадные таблицы стилей используются для визуального форматирования разметки. Элементарной единицей CSS является селесктор - элемент или признак элемента HTML разметки к которому нужно применить некоторый набор свойств. В чистом виде селекторы применяются редко, обычно они объединяются в правило. Правило - некоторая последовательность селекторов.

Общий синтаксис CSS выглядит примерно так:
```css
/* Правило состоящее из одного селектора */
selector-name {
    property1: value1;
    property2: value2;
}

/* Правило из нескольких селекторов*/
selector-name selector-another-name {
    property1: value1;
    property2: value2;
}

/* Один набор свойств для разных правил*/
selector-name,
selector-another-name,
selector-name selector-another-name {
    property1: value1;
    property2: value2;
}
```

CSS может применяться как стили объявленные в теле документа или как ссылка на ресурс. 

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            <!-- document body style -->
            selector {
                property1: value1,
                property2: value2,
            },
        </style>
    </head>
    <body>
    </body>
</html>
```
Каждый из способов применения стилей имеет свои преимущества и недостатки. 
Стили объявленные как ссылка на ресурс кешируются браузером при первой загрузке страницы, при последующем визите страницы стиль загружаться не будет и будет применен сразу. С другой стороны загрузка стилей происходит _асинхронно_ т. е. в ходе разбора HTML браузером, браузер увидев ссылку условно даст команду _начать загрузку стилей_, и применить их по окончании загрузки. В случае, когда файл с css достаточно объемный или соединение с сетью имеет низкую скорость, могут случиться ситуация когда пользователь сначала  увидит **"голую"** разметку, а когда загрузится CSS страничка резко преобразитья - что не очень приятно.

Стили объявленные как часть документа обрабатываются браузером как и весь остальной HTML проблема опичанная выше при таком подходе произойти не может, однако эти стили загружаются каждый раз и читаются каждый раз при перезагрузке страницы, что технически при низкой скорости соединения и большом объеме HTML приведет к тому что страничка может долго отрисовываться браузером, и пользователь дого будет наблюдать пустую страницу.

В заваисимости от архитектуры приложения каждый из этих подходов может быть применимы более или менее, однако в ходе обучения будем подключать css **исключительно как ссылку на ресурс** сейчас это наиболее частая практика, а стили объявленные в теле документа используются для _затыкания узких мест_

> **Важно** каждый браузер по умолчанию имеет свои встроенные стили стили. При верстке страницы крайне рекомендуется явно устанавливать все стили. Явно и не рассчитывать на авось, ну и проверять верстку в несколькольких браузерах.

> **Важно не меньше** каждый браузер по- разному поддерживает те или иные возможности CSS для оценки возможности применения тех или иных возможностей CSS рекомендуется проверить их поддержку в [Can I use](https://caniuse.com/). Про [webref](https://webref.ru/)

## Селекторы

Для лучшего понимания селекторов рекомендую ознакомиться со статьей [30 css селекторов которые вы должны запомнить](https://code.tutsplus.com/ru/tutorials/the-30-css-selectors-you-must-memorize--net-16048).

**Родительский элемент** - элемент в нутри которого находятся другие элементы.

**Дочерний элемент** - элемент находящийся внутри элемента, для такого элемента родительстким элементом всякий элемнт котрый находится выше в иерархии HTML разметки.

**Соседний злемент** - элемент находящийся на одном уровне иерархии 
```html
<!DOCTYPE html>
<html lang="ru"> <!-- Элемент родительский для всех -->
    <head> <!-- Элемент дочерний для html -->
        <meta charset="UTF-8"> <!-- Элемент дочерний для html и head -->
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
        <title>Window title</>  <!-- Элемент соседний с link -->
        <link rel="stylesheet" href="path-to.css">
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>

    </head>
    <body>
    </body>
</html>
```
Наиболее частоиспользуемыми селекторами являются:

- **идентификатор** - применяется к элементу помеченному атрибутом `id`, идентификатор должен быть уникален в пределах одной страницы, если на странице будет несколько элементов с одинаковым идентификатором, HTML и браузер промолчат, это будут ваши проблемы но вас предупредили;
```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            <!-- этот стиль -->
            #root {
                background: #cecece;
            }
        </style>
    </head>
    <body>
        <!-- будет применен к этому элементу -->
        <div id="root"></div>
    </body>
</html>
```
- **тэг** - применяется к определенному теку в пределах всего документа;

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            <!-- этот стиль будет применен только к тэгу html-->
            html {
                font-family: 'Open Sans';
            }
        </style>
    </head>
    <body>
        <!-- будет применен к этому элементу -->
        <div id="root"></div>
    </body>
</html>
```
- **класс** - наше все применяется ко всем элементам помеченным атрибутом `class`, с указанным значением. атрибут класс может содержать условно бесконечное множество значений. Можно применять правило к элементу отмеченному несколькими значениями.
```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            <!-- Это правило применится ко всем элементам с классом text -->
            .text {
                font-size: 14px;
                text-transform: uppercase;
            }
            <!-- Это правило применится ко всем элементам с классом block -->
            .block {
                padding: 10px;
                color: red;
            }
            <!-- Это правило применится ко всем элементам с классом block и text одновременно -->
            .text.block {
                font-size: 12px;
                background: green;
            }
        </style>
    </head>
    <body>
        <div id="root">
            <!--будет применено правило .text -->
            <p class="text">
                Text
            </p>
            <!--будет применено правило .block -->
            <div class="block">
                Text
            </div>
            <!--будет применено правило .text -->
            <div class="text">
                Text
            </div>
            <!--будет применено правило .text .block .text.block -->
            <div class="block text">
                Text
            </div>
        </div>
    </body>
</html>
```
- **просто добавь контекст** - сочетания селекторов, позволяют ограничивать область применения тех или иных селекторов.
```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            <!-- Это правило применится ко всем элементам с классом text, находящихся внутри элемента помеченного классом root -->
            .root .text {
                font-size: 14px;
                text-transform: uppercase;
            }
            <!-- Это правило применится ко всем элементам с классом block -->
            .block {
                padding: 10px;
                color: red;
            }
            <!-- Это правило применится ко всем элементам с классом block и text одновременно -->
            .text.block {
                font-size: 12px;
                background: green;
            }
        </style>
    </head>
    <body>
        <div id="root">
            <!--будет применено правило .text -->
            <p class="text">
                Text
            </p>
            <!--будет применено правило .block -->
            <div class="block">
                Text
            </div>
            <!--будет применено правило .text -->
            <div class="text">
                Text
            </div>
            <!--будет применено правило .text .block .text.block -->
            <div class="block text">
                Text
            </div>
        </div>
        <div class="footer">
            <!-- правил применено не будет!!!!!! -->
            <p class="text">
                Text
            </p>
            <!--будет применено правило .block -->
            <div class="block">
                Text
            </div>
            <!--будет применено правило .text -->
            <div class="text">
                Text
            </div>
            <!--будет применено правило .text .block .text.block -->
            <div class="block text">
                Text
            </div>
        </div>
    </body>
</html>
```
> **Осторожно!** CSS всего не написать и не прересказать. за подробностями [сюда](https://webref.ru/css)

## Тексты и шрифты, а точнее наоборот

Про форматироване текста можно прочитать вы сами знаете где. Особое значение следует уделить шрифтам. Шрифт устанавливается указанием свойства `font-family`, свойство допускает установку нескольких значений, сделано это по той причине, что по умолчанию браузер пытается подключить шрифты _уже имеющиеся на компьтере пользователя_, однако на компьютере может не быть того семейства шрифтов, которое было указанного как значение свойства, если его нет то браузер попытается применить семейство шрифтов, которое указано вторым, если нет второго, попытается установить третье, когда варианты закончатся браузер применит тот шрифт, что настроен у него по умолчанию.

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            <!-- Шрифты содержащие в названии несколько слов указываются в апострофах -->
            html {
                font-family: 'Open Sans', Arial, sans-serif;
            }
        </style>
    </head>
    <body>
        <!-- будет применен к этому элементу -->
        <div id="root"></div>
    </body>
</html>
```
Шрифт является критически важной состовляющей сайта, и запасные варианты, могут, быть неприемлемы. Как обеспечить чтобы у каждого пользователя был один и тотже шрифт? Шрифт должен быть частью ресурсов сайта. Шрифт может быть загружен либо с домена самого сайта, либо c [fonts.google.com](https://fonts.google.com)

Еще одна особенность шрифтов - **авторское право** да, многие стоят денег, шрифты в [fonts.google.com](https://fonts.google.com) в большинстве бесплатные, а если и платный вас перенаправят туда где его можно купить. Еще одна особенность шрифтов - не все имеют набор кирилических символов, а еще в зависимости от шрифта богут быть разные значения жирности.

Шрифты с [fonts.google.com](https://fonts.google.com) подключать как CSS стиль.

Также стоити отметить, что есть иконочные шрифты например [Font Awesome](https://fontawesome.com)

## Блоки (элементы) отображение и позиционирование

Как было сказано ранее есть блочные тэги (элементы) и строчные, однако, это повевение можно менять, и заставить любой тэг отображаться как блок, строку, таблицу, скрыть или не отображать содержимое (да, да есть тонкая грань).

Для того чтобы задать способ отображения элемнетна, необходимо указать свойство `display`. Значения свойства `display` могут быть:
- **block** - указывает элементу, что он должен вести себя как блочный;
- **inline** - указывает элементу, что он должен вести себя как строчный;
- **inline-block** - указывает элементу, что его поведение сочетает поведение блочного и строчного элемена;
- **table** - в сочетании с элементами  со свойствами **table-row** и **table-cell** позволяет сделать таблицу без тэга `table`.
- **flex** - наше все, inline-block, котороый мы заслужили, подробнее [здесь](https://webref.ru/layout/visual-guide-flexbox);
- **none** - скрывает элемент в документе, элемент с этим свойством никак визуально не виден, и нет признаков того, что он вообще в документе присутствует, можно скрыть элемент испоьльзуя свойство `visiibility: hidden`, однако в этом случае, хоть содержимое этого элемента и не будет видно, будет видно место которое этот элемент занимает.

Блокам могут быть назначены внешние `margin` и внутреннае `padding`. Важно отметить, что внешние блоки элементов при пересечении не суммируются, т.е. если у двух элементов, следующих друг за другом, указаны внешние отступы 10px, то расстояние между ними будет не 20px, а 10px, если отступы неравны, будет взят больший.

```css
/* Для padding аналогично */
.header {
    margin: 10px; 
    margin: 10px 5px; /*внешний отступ 10xp сверху и снизу, 5px слева и справа*/
    margin: 10px 15px 5px; /*отступ сверху 10px, слева/справа 5px, 15px снизу*/
    /*Эти свойства говорят сами за себя*/
    margin-left: 10px; 
    margin-right: 10px; 
    margin-bottom: 10px; 
    margin-top: 10px;
}
```

Отличительной особенностью внутренних отступов является их влияние на размер элемента, размеры можно указывать посредством свойств `width`, `height`, `max-width`, `max-height`.

```CSS
.header {
    max-width: 1200px; /*максимальная ширина блока*/
    width: 100%; /*шинрина блока будет 1200, ведь максимум 1200*/
    height: 80px;
    padding: 0 20px; /*ну не совсем, ширина будет 1240, padding добавит*/ 
}
```
Для предотвращения такого поведения необходимо указать свойство `box-sizing: border-box;`, указание этого свойства, с таим значением. меняет модель расчета размеров блока, как правило это свойство задается глобально, для всех блчных элементов.

```CSS
.header {
    box-sizing: border-box; 
    max-width: 1200px; /*максимальная ширина блока*/
    width: 100%; /*шинрина блока будет 1200, ведь максимум 1200*/
    height: 80px;
    padding: 0 20px; /*ширина будет 1200, с внутренним отступом 20px справа и слева*/
}
```
Блокам может задаваться граница подробнее [здесь](https://webref.ru/css/border) граница может задаваться как одна для всех граней блока так и для каждой грани отдельно. граница имее толщину, толщина границы **добовляетя** к конечному размеру блока. Границе можно указывать радиус скругления как для всех шраниц, так для каждого угла в отдельности подробнее [здесь](https://webref.ru/css/border-radius).

```CSS
.header {
    width: 80px;
    height: 80px;
    border: 1px solid #000000; /*Сплошная граница толщиной один пиксель черного цвета*/
    border-radius: 50% /*И квадрат превращается в круг*/
    /*общий размер блока должен быть 82px на 82px*/
}
```
Блокам может задаваться [тень](https://webref.ru/css/box-shadow), или даже несколько.

С помощью внешних отступов можно можно выровнять блок по центру экрана.

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            <!--Это правило, будет центрировать блок с id root по центру экрана, ширина экрана может быть 1920 однако содержимое будет занимать ширину 1180 и оно будет располагаться по центру экрана-->
            #root {
                max-width: 1180px;
                width: 100%;
                margin: 0 auto;
            }
        </style>
    </head>
    <body>
        <!-- будет применен к этому элементу -->
        <div id="root"></div>
    </body>
</html>
```

Псевдоэлементы. Псевдоэлементы могут добавляться как к блочным так и к строчным элементам. Особенность псевдоэлементов, в том что они не объявляются в HTML документе, но в документе отображаются. **Псевдоэлементы** задаются _только_ через CSS. Для указания псевдоэлемента в селесторе (правиле) указывается `::before` и/или `::after`. Расположение элементов говорит само за себя, но использоваться могут как угодно разработчику.

```CSS
.header::after {
    content: ''; /*чтобы элемент стал виден необходимо указать это свойство*/
    display: block;
    height: 100px;
    width: 100px;
    background: #cecece;
}

.header::before {
    content: ''; /*чтобы элемент стал виден необходимо указать это свойство*/
    height: 50px;
    width: 100px;
    background: green;
}
```
Бывают ситуации когда содержимого дочерного элемента слишком много для родителя, для таких случаев существует свойство `overflow` [тык](https://webref.ru/css/overflow), и его частные случаи `overflow-x` и `overflow-y` смотреть там же.

Позиционирование блоков. для позиционирования блоков используется свойство `position`, совместно со свойствами `top`, `right`, `left`, `bottom`. Основными значениями свойсва `position` являются:
- **static** - применяется поумолчанию;
- **relative** - положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения;
- **absolute** - абсолютное позиционирование. Указывает, что элемент абсолютно позиционирован, при этом другие элементы отображаются на веб-странице словно абсолютно позиционированного элемента и нет. Положение элемента задаётся свойствами `left`, `top`, `right` и `bottom`, также на положение влияет значение свойства `position` родительского элемента. Так, если у родителя значение `position` установлено как static или родителя нет, то отсчёт координат ведётся от края окна браузера. Если у родителя значение `position` задано как `relative`, то отсчёт координат ведётся от края родительского элемента;
- **fixed** - фиксированное позиционирование. По своему действию это значение близко к `absolute`, но в отличие от него привязывается к указанной свойствами `left`, `top`, `right` и `bottom` точке на экране и не меняет своего положения при прокрутке веб-страницы.

- **stycky** - подробнее сами знает где... вроде работает, а вроде и нет.


Сочетание `position: relative` и `position: absolute`, позволяет творить _"чудеса"_. Элемент, который помечен свойством `relative` становится для дочернего элемента помеченного свойством `absolute` своего рода _"холстом"_ в пределах которого можно передвигать элемент.

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            .relative {
                position: relative;
                width: 500px;
                height: 500px;
                background: red;
            }

            .absolute {
                position: absolute;
                background: green;
                top: 50px;
                bottom: 50px;
                left: 50px;
                right: 50px;
            }
        </style>
    </head>
    <body>
        <div id="root">
            <div class="relative">
                <div class="absolute"></div>
            </div>
        </div>
    </body>
</html>
```
Результатом такой разметки будет красный квадрат размером 500х500 пикселей, внтри которого будет квадрат зедленого цвета размером 400х400 пикселей. При использовании позиционирования `absolute` и `fixed` и свойств `top`, `bottom`, `left`, `right` эти свой свойства могут растягивать элемент.

Элемент, имеющий `position:fixed`, как бы выпадает из основного потока элемента, он отображается, но браузер делает вид, что такого элемента в указанном месте нет, т.е. места такой элемент не занимает. Также такой элемент отображает только содержимое, установленные ранее внешние отсупы игнорируются.

Бывают ситуации, когда блоки нужно расположить не один за другим сверху вниз, а слева на право, для этого можно использовать `display: table`, но не всегда нужно подумать дважды, `display: flex` сейчас это лучшее решение, а так же `float: left`, `float: right` изначально, эти свойства использовались для обтекания изображений текстом, но и для блоков работает, и долгое время это было _стандартом_, просто за неимением лучшего. Фатальный недостаток `float: left` - он так же как и `fixed` ломает поток документа, но это лечится установкой элемента со свойствaми `clear: both` и `display: block`.

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css"> <!-- link to resource-->
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript"></script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css">
            .float {
                float: left;
            }
            .width {
                width: 33%;
            }
            .clearfix {
                clear: both;
            }
        </style>
    </head>
    <body>
        <div class="float width">
            Content
        </div>
        <div class="float width">
            Content
        </div>
        <div class="float width">
            Content
        </div>
        <div class="clearfix"></div>
    </body>
</html>
```

## **_Адаптивная (отзывчивая) верстка_**

Для обеспечения адаптивной верстки используются _медиа запросы_ подробне [тут](https://webref.ru/css/media) и [там](https://webref.ru/css/value/media). Отмечу, есть тонкая грань между адаптивной версткой, и отзывчивой. Адаптивная, по сути, представляет из себя масштабирование сайта по размеру экрана (одна разметка и один CSS на все разрешения дисплеев). Отзывчивая - перестроение, сокрытие или демонстрация элементов разметки, и применение разных правил, или зменение отдельных свойств правил, в зависимости от разрешения экрана. Впрочем, с этими терминами до сих пор куча путаницы, и кто как не называет. На сегодняшний день, де-факто стандарт поддержки различных мониторов на английском значится как **Responsive design** (отзывчивый дизайн), на русском хоть отзывчивый, хоть адаптивный имеют в виду одно и тоже, трудности перевода, однако.

Судь адаптивной верстки, в определении так назывемых **breakpoints** (не путать с точками останова при отладке), размеров экрана при котором, должен применитья новый набор правил, по умолчнию можно использовать breakpoints определенные в CSS фреймворке [bootstrap](https://getbootstrap.com/docs/4.4/layout/overview/) в целом они универсальны, но никто не запрещает вам определить свои, или дополнить существующие.

Объявление медиа запроса выглядит следующим образом, медиа запросы объявляются внутри _css_ файлов.
```css
.selector {
    property1: value1;
    property1: value1;
}

/* набор правил для разрешения больше 800px */
@media screen and (min-width: 800px) {
    .selector {
        property1: value-for-resolution-more than-800px-1
    }

    /*Это правило применяется только при разрешении экрана 800px*/
    /*Однако в разметке элемент с таким селектором должен быть объявлен*/
    .800px-selector {
        property1: value-for-resolution-more than-800px-1
    }
}

/* набор правил для разрешения меньше 1000px */
@media screen and (max-width: 1000px) {
    .selector {
        property1: value-for-resolution-less than-1000px-1
    }

    /*Это правило применяется только при разрешении экрана более 800px*/
    /*Однако в разметке элемент с таким селектором должен быть объявлен*/
    .800px-selector {
        property1: value-for-resolution-more than-800px-1
    }
}

/*Набор правил действующих при разрешении более 800px и менее 1000px*/
@media screen and (min-width: 800px) and (max-width: 1000px) {
    .selector {

    }
}
```

**Важно** - велик соблазн, в зависимости от разрешения скрывать или показывать целые блоки разметки, не надо так, следует продумывать наборы css правил и менять свойства им, хотя действительно бывают ситуация когда нет иного пути как взависимости от разрешения скрвать или отображать элементы разметки.


Это далеко не все о CSS подробнее можно узнать сами знаете где. Ну а пока...
Посмотрите на сайт посвещенный [Ёжику](http://localhost:8080/hedgehog)

> Задание 1.
> 
> Внимательно изучите HTML разметку файла hedgehog.html
> 
> Крайне внимательно изучите содержимое css-файлов hedgehog и hedgehog-`block-name`, block-name, соответствует имени блока страницы. Я сказал **внимательно**!!! Это не значит что нужно смотреть и тупить, это значит что нужно произвести обратный инжиниринг кода, комментируя правила, а потом и строки в них, изучая их действия. Если видите незнакомые свойства вы можете узнать о них вы сами знаете где.
>
> Блок header, подумайте как сделать так, чтобы блок был всегда вверху страницы и видим.
> Ответьте на вопрос почему нижние подчеркивание пунктов меню сделано так как оно сделано, как сделать такое же но иным путем?
> 
> Блок banner как сделана полупрозрачная подложка в левой части?
> 
> Блок about почему портрет ежа вылезает за пределы контейнера?
>
> Блок features - как сделана карточка в центре почему она больше других, есть ли альтернатиыный способ. Как сделана ленточка в верхнем правом углу?
>
>Блок enemies - как достигается одинаковый размер и отображение фотографий? Каким оразом отображается подпись при наведениина картинку, а так же увеличивается изображение.
>
>Блок life - да это только CSS с html как заменить линии на тнебольшие указательные треугольники.
>
>Блок chat - вот я точно не уверен, подумаете, можноли сделать так, чтобы в случае когда от одного автора отправляется несколько сообщений подряд, не отображалась фотография отправителя, и его имя.
>
>Блок register - .....
>
>Блок footer - Закомментируйте содержимое страницы, оставьте только footer и header, объясните как footer остается прижатым к низу страницы.
>
>Сделайте эту страницу адаптивной, когда появится соответствующий материал.
Особенно уделите внимание меню, для разрешений планшетов и мобильных телефонов, перед логотипом должен отображаться значек меню, он же гамбургер, он же три полоски, а сами пункты меню должны должны отображаться в столбик, под логотипом.




