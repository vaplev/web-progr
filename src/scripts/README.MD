# Java Script (front-end)

Пункт перый, он же важный все что нужно знать о JavaScript написано [здесь](https://learn.javascript.ru) и [здесь](https://developer.mozilla.org/ru/docs/Web/JavaScript).

JavaScript (JS)- язык программирования с неявной динамической слабой типизацией. Общее у JavaScript и Java - слово Java и некоторые синтаксические конструкции и правила к оформлению кода. Язык является интерпретируемым. Долгое время был языком применяемым исключительно в браузере для придания динамики страниц, манипулируюя элементами разметки документа. Однако, на данный момент, JS можно считать языком программирования общего назначения, сейчас его не применяют разве что для разработки под тапки, но это не точно, к моменту прочтения ситуация может измениться. 

К коду HTML JS подключается через тэг `<script></script>`, код js может быть описан как внутри тэга `script`, так и через атрибут `src` хорошей практикой считается именно подключение через `src`, тэг `script`, может подключаться в любом месте документа, однако, надо учитвыать, что при загрузке скрипта отрисовка разметки документа приостанавливется до завершения загрузки, а загружаемый скрипт, сразу же интерпретируется и исполняется браузером, по этой причине, скрипт маниулирующий HTML разметкой документа загружть вначале документа нет никакого смысла.

Подключение скриптов к HTML документу.

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Window title</>
        <link rel="stylesheet" href="path-to.css">
        <link rel="icon" href="favicon.icon">
        <script type="text/javascript">
            console.log('Hello world!'); //js code
        </script>
        <script src="path-to.js" type="text/javascript"></script>
        <style type="text/css"></style>
    </head>
    <body>
        <script type="text/javascript">
            console.log('Hello world, again!'); // js code
        </script>
        <script src="path-to.js" type="text/javascript"></script>
    </body>
</html>
```

Проблема зависимостей, и областей видимости. В силу того, что JS такой какой он есть при загрузке нескольких скриптов, может случиться конфликт объявляемых переменных или функций, если допустим в двух файлах скриптов объявлена переменная `a` и в одном это строка, а в другом число, подобное может сломать скрипт, раньше это лечилось применением паттерна [модуль](https://learn.javascript.ru/closures-module#priyom-proektirovaniya-modul) нынче это эту проблему решает [webpack](https://webpack.js.org). Другая беда это зависимость кода поскольку скрипты загружаются по мере их объявления, важно было тщательно выстраивать граф зависимостей, иначе могла случится ситуация когда один скрипт использует функции скрипта кторый еще не был загружен.

Еще одной бедой долгое время были сами браузеры, которые умудрялись, по разному интерпретировать JS, и некоторые воможности языка могли поддерживать одни браузеры и не моги другие, привет **Internet Explorer** - ночной кошмар web-разработчиков.

С появлением node.js и "серверного js" также пеоявились различия в применении синтаксиса.

В JS самое главное это функция, при разборе кода интерпретатор в первую очередь ищет функции.

В прочем как сказал Линус Торвальд
> Words are cheap show me the code

Поехали.

## **Переменные**

Для объявления переменных использется ключевое слово `var`, также используются ключевые слова `let` и `const`, однако они используются на серверной части, на клиентской части их можно использовать только с подключенным [babel](https://babeljs.io/) и [webpack](https://webpack.js.org)
```javascript
var a = 10;
var name = "Andrew" // сторока
var lastName = 'Lobov'; // тоже строка разницы между объявлением строки с помощью апострофов и кавычек нет; 
name = 10; // Динамическая типизация) возможно вы уже заметили, не везже проставлена ; конце строки, ибо это не обязательно JS стерпит но лучше придерживаться одного стиля.

/*
camelCase используется для объявления переменных и функций, (исключение классы) увижу что другое расстел.
*/

var b; // можно, но стоит подумать, возможно имеет смысл установить значение null, или значение по умолчанию, для того типа который планируется использовать.

var c, d, у; //так тоже можно объявлять пременные. Увижу такое объявление пристрелю, одна переменная одна строчка, считайте это моей придурью.
console.log(d); // выведет undefined это работает для всех элементов которым не было присвоено значений или необъявленным.
var isJsRules = false; // переменная булевского типа типа;
var date = new Date(); //переменная даты/времени.

var float = -100.5; // Переменая действительного типа, учтите, в JS есть только действительный тип с плавающией запятой.

// Основные операции

var result = ((2 + 2 - 1) * (6 / 2)) % 3; // ничего необычного % остаток от деления на n

var fulName = name + ' ' + lastName; // сложение строк

var isEqual = 2 == '2'; // ага, так мможно, результат true;
var isReqalyEqual = 2 === '2'; // false, чем больше равно тем точнее сравнение

var toBeOrNotToBe = isEqual !== isRealyEqual // nернарный оператор
    ? 'To be' // значение если true
    : 'Not to be'; // значение если false ;

a += 100; // инкремент
a =+ 1; // тоже инкремент, но в чем разница не помню) с - и *  тоже работает.

const gravity = 9.8; // когда поддерживается, попытка изменить вызовет ошибку.

let value = 100; // когда работает, тогда работает, объявление действует только на область видимости.

let power = Math.pow(10, 2); // Math for mathematics
```
## **Функции**

Для объявления функций испоьзуется ключевое слово `function` для возврата значения или прерывания выполния функции `return`. При разборе JS функции ищутся в первую очередь, есть два способа объявления функции function definition и function expression;

```javascript

sayHello() // 'Hello World!' 
// function definition
function sayHello() {
    var hello = 'Hello world'; // локальная переменная для функции
    console.log(hello);
}

hello(); // undefined
// function expression объявляется как переменная, работает как функция. 
var hello = function() {
    console.log('Hello world');
}

hello() // 'Hello World!' в этом разница между function definition and function expression

// Функция с параметрами, возвращающая значение. проверка списка параметров и их типов не производится!!!
function add(firstValue, secondValue) { 
    return firstValue + secondValue;
}

// Функция которая выполняет над первыми двумя параметрами действия 
// указанные в третьем параметре, который должен быть функцией
// привет делегаты)
function numbersAction(firstValue, secondValue, callbackFunction) {
    var actionResult = callbackFuction(firstValue, sercondValue);
    return actionResult;
}

// применение, когда действие объявленно отдельной функцией
numbersAction(1, 2, add); // результат 3

// применение, когда действие объявлется при вызове функции
numbersAction(1, 2, function(a, b) {
    a+=10; // firstValue будет 11
    b = b * -1; // secondValue -2
    return a * b // ресультат -22 если я не путаю
}); 

// значение параметров по умолчанию
// модификация функции sayHello

function sayHello(name = 'World') {
    console.log('Hello, ' +name + '!');
}

sayHello(); // Hello, World!;
sayHello('Andrew'); // Hello, Andrew!

/*
Важно не тип не список параметров при вызове функций не проверяется!!! 
Для провеки типа можно использовать typeof, если параметр требуется то его можно обработать и в случае отсутсвия кинуть исключение throw 'Error' ищите try catch
*/

// Да и такое бывает
function counter(initValue) {
    var value = initValue || 0;
    return function() {
        return value += 1;
    }
}

var counter1 = counter(10);
counter1(); // 11
counter1(); // 12

var counter2 = counter();
counter2(); // 1
counter2(); // 2
/* Как-то так, если я не накосячил */


//На серверной стороне и под babel можно использовать стрелочные функции

numbersAction(1, 100, (a, b)=> { // function(a, b) заменяется на (a, b)=>
                                // для случаев когда список параметров 
                                //пуст  ()=>
    return a - b;
})
```

## **Массивы**

С массивами все просто, главное что нужно знать - нумерация начинается с 0.
Так как с типизацией все печально элементами массива может быть все что угодно. Массив не значение массив ссылка, ну если ввы понимает о чем я...
у массива есть ряд полезных функций:

- forEach - проход по всем элементам;
- map - проход по всем элементам, и создание нового массива;
- reduce - проход по всем элементам и агрегация конечного значения;
- some - проход по всем элементам и проверка удовлетворяет ли хотябы один элемент условию;
- every - проход по всем элементам и проверка удовлетворяет ли каждый элемент условию;
- sort - сортировка массива по указанному признаку;
- find - находит первый элемент удовлетворяющий признаку;
- findIndex - находит индекс первого элемента удовлетворяющего признаку;
- filter - возвращает новый массив состоящий из элементов удовлетворяющих условию.

Подробности [тут](https://learn.javascript.ru/array) и [тут](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

Полезная библиотека для работы массивами [lodash](https://lodash.com/)
```javascript
// Объявление и инициализация элементов массива
var items = [1, 'Andrew', [1,2,3], false, new Date()]; 
var numbers = [];

numbers.push(1); // добавляем элемент в массив, размерность массива увеличивается
numbers.push(2); // добавляем элемент в массив, размерность массива увеличивается

var secondElement = numbers[1]; // 2;

secondElement = numbers.pop(); // возвращает 2, при этом удаляя это значение из массива.


numbers.push(10, 20, 30);

// Проход по массиву
numbers.forEach(function(item, index) {
    console.log(index);
    console.log(item);
});

//Удалять элементы лучше через splice

numbers = numbers.splice(1, 1); // индекс удаляемого объекта, количество удаляемых элементов.
```

## **Объекты**

Объекты в JS представлены в двух эпостаясях первое как экземпляр класса, второе как некая структура данных с единой "точкой входа"и ключами доступа к членам структуры.

```javascript
var user = {}; // пустой объект
user = {
    firstName: 'Andrew' // имя свойства: значение
    lastName: 'Lobov',
    contats: {
        vk: 'lobov_av',

    }
}

console.log(user.firstName);  // Andrew
console.log(user.contacts.vk); // lobov_av

user.contacts.phone = '111-222-333'; // Добавили новое свойство объекту

user.firstName = 'Vasya'; // Установка нового значения свойства
user['firstName'] = 'Andrew' // Установка нового значения свойства, через доступ по ключу

// можно указывать значени ключа как строку но и доступ будет только через ключ
user["Soft skills"] = ['speaking, writing, hating'];
user.sayHello = function() { // и такое можно
    console.log('Hello!')
}

user.sayHello();

// Массивы объектов
var points = [
    { 
        x: 1,
        y:1 
    },
    { 
        x: 2,
        y:4 
    },
    { 
        x: 3, 
        y :9 
    },
];

/* Объект как экземпляр класса */

// Только в этом случае название с большй буквы
function Product(name, price) { // параметры конструктора
    this.name = name; // публичные свойства
    this.price = price;
    this.sayHello = function () {
        console.log('Hello')
    }
}

var product = new Product('Juice', 100);
// Я просто оставлю это здесь https://learn.javascript.ru/object-basics

```

## **Даты**

Даты в JS - это боль, первое точка отсчета дат 1 января 1970, второе месяцы свинуты на -1. Одна радость [moment.js](https://momentjs.com/)
Подробности [здесь](https://learn.javascript.ru/date)

```javascript
// Создание даты
var date = new Date(1989, 10, 6); // год, месяц, день, и месяц здесь, не октябрь
var dateAndTime = new Date(1989, 10, 6, 12, 15, 49, 500)
var today = Date.now();
```

## **Условия**

С уловиями в JS нет ничего оригинального, ну разве что _null_, _''_, _""_, _0_, _false_, _undefined_ в блок проверки условий ввоспринимается как **false**.

```javascript

var condition = true;

if(condition) { 
    // типа код
}

/* Со следующего офрмления кода у меня неимоверно бомбит */
if(condition) 
    // одна строчка кода 
/*но так можно, но не стоит, правда...*/

if(conditions) {
    //типа код
} else {
    // код когда что-то пошло не так
}

if(conditions) {
    //типа код
} else if(anotherCondition) {
    // код когда что-то пошло не так
} else if (anotherConditionAgain) {

}

/* До сих пор не понимаю, зачем это используют */
switch(x) {
    case 'value1': 
        //типа код строка раз
        //типа код строка два
        break;
    case 'value2' : 
        //типа код строка раз
        //типа код строка два
        break;
    default: 
        //типа код когда вариантов нет строка раз
        //типа код когда вариантов нет строка два
}

/* операторы сравнения  */

var biggerThan = 1 > 0; // true
var biggerOrEqualThan = 1 >= 0; // true
var lessThan = 1 < 0; // false
var lessOrEqualThan = 1 <= 0;  // false;

var isEqual = 1 == 1; // true
var isRealyEqual = 1 == "1"; // true ага, вот так вот == это слабое стравнение
var isRealyEqualStrong = 1 === "1"; // false типы однако, больше равенства богу, равентсва

var isNotEqual = 1 != 1; // false
var isNotEqualStrong = 1 !== 1; // false да-да, строгое равенство и неравенство

var complexConditionAnd = (1===1) && ('Andrew' === 'Lobov'); // false
var complexConditionOr = (1===1) || ('Andrew' === 'Lobov'); // true
```


## **Циклы**

С циклами все предельно скучно.

```javascript
// цикл на 10 итераций
for(var i=0; i < 10; i++ ) {
    // типа код
    if(i === 5) {
        continue; // немедленный переход на следующую итерации
        break: // ломаем цикл
    }
    console.log(i);
}

// специальный цикл для перебора элементов объекта
for (var key in object) {
    var element = object[key];
}

// цикл с постусловием 
do {
    // типа код
} while (condition)

// цикл с предусловием
while (condition) {
// типа код
} 
```
## **Замыкания**
ОБъяснять долго подробнее [здесь](https://learn.javascript.ru/closure) и [здесь](https://habr.com/ru/company/ruvds/blog/424967/)

## **JSON**

JavaScript Object Notation (JSON) - формат сериализации объектов в JS, который стал наиболее распространенным механизмом обмена данными между системами. Сериализация - сохранение объекта, находящегося в оперативной памяти в долговременную память. Десериализация - сериализация с точностью до наоборот.

```json
/*важно! комментарии к этому коду условны*/
/*в самом JSON коммментарии нодопустимы*/
{
    "IntegerValue": 1, // имена свойств обязательно в двойных кавычках
    "doubleValue": 1.3232,
    "stringValue": "This is string", // строки только в двойных кавычках
    "arrayValues": ["Andrew", "Vlad", "Victoria"], // может быть сериализован массив
    "boleanValue": false,
    "dateValue": "2020-12-22", // Дата может иметь различный формат
    "objectValue": {
        "propertyValue1": 1,
        "propertyValue2": "Hello",
        "propertyValue3": [1, 2, 3, 4],
    },
    "objectArrayValue": [
        {
            "propertyValue1": 1,
            "propertyValue2": 2

        },
        {
            "propertyValue1": 1,
            "propertyValue2": 2
        }
    ]
}

/********************************************************/
/* Дата, как правило, представляется в виде строки,     */
/* формат строки может зависеть от среды в которой был  */
/* сериализован объект                                  */
/********************************************************/

/* JSON может быть представлен массивом  */
[ // смотрите на первую скобку
    {
        "propertyValue1": 1,
        "propertyValue2": 2

    },
    {
        "propertyValue1": 1,
        "propertyValue2": 2
    }
]
```

Для работы с JSON используется класс `JSON`

```javascript
var objects = [
    { 
        name: 'Andrew', 
        lastName: 'Lobov'
    },
    { 
        name: 'John', 
        lastName: 'Doe'
    }
];

var serializedObj = JSON.stringify(objects);
console.log(serializedObj);

var deserializedObj = JSON.parse(objects);
console.log(deserializedObj);
```

##  **Промисы интервалы и таймауты**

При реализации некоторых задач, порой возникает потребность выполнить некоторый набор инструкций не немедленно, а через некоторый промежуток времени для закрытия такой потребности исмользуется метод `setTimeout`.

```javascript

function delayExecution(argument1, argument2) {
    console.log('delay execution');
}

setTimeout(
    delayExecution, // Функция которая будет вызвана
    1000,           //через 1 секунду (1000) миллисекунд
    'argument1-value', 'argument1-value' // значения параметров
);
/* 
Для отложенных действий не обязательно отдельную объявлять фукцию,
функциию можно объявить непосредственно при вызове setTimeout
*/

setTimeout(
    function (argument1, argument2) { // или стрелочная функция
        console.log('delay execution');
    }
    1000,
    'argument1-value', 'argument1-value' 
);
```

Так же бывает ситуакции, когда необходимо выполнять одну туже процедуру периодически. Для таких ситуаций существует `setInterval`. Вцелом все аналогично `setTimeout`

```javascript

var timer = setInterval(function(argument1){
    console.log(argument1);
}, 1000 * 5, 'Hello!');

clearTimeout(timer); // прекращает выполнение периодической задачи.

```

Промисы. Существуют ситуации, когда нужно выполнить затратный по времени набор инструкции, а после выполнения продолжить выполнять дествия с результатом работы, при этом есть набор команд, котрые от результата выполнения затратного набора никак не зависят и могут быть выполнены, но ждут своего часа. Такое поведение называется асинхронным выполнением кода, возможно, ч этим вы уже знакомы. В силу самого себя JS асинхронен, нужно только воспользоватся этой возможностью, создать объект Promice и поместить в него функцию.

```javascript

var longTimeAction = new Promise( // создаем объект Promise
    function( // объявление выполняемой функции
        resolve, // функция, вызываемая в случае успешного выполнения 
        rexect) // функция, вы вызываемая в случае ошибки
        { 
            // тело функции
            // иммитация долгого выполнения с помощью setTimeout

            setTimeout(() => {
                console.log('Longntime action');
                
                resolve('Action complete'); // вызов функции успешного выполнения
                           // возвращаемый результат указывается в скобках
                reject(new Error('Error text'));

            }, 1000 * 10);
    }
);

/* Применение промиса */

console.log('begin task');
longTimeAction.then(function(result) {
    console.log(result);
}).catch(error=> {
    console.log(error);
});
console.log('end task');

/* Результат работы будет следующим */
// begin task
// end task
// через 5 секунд будет выведено Action complete

```

## **Взаимодействие с DOM и BOM**

Изначальной задачей JS было взаимодействие с DOM (Document Object Model), объекной модели документа, который представляет  все содержимое страницы которое можно менять. Отправной точкой взаимодействия с DOM яавляется объект `document`. К счастью, или сожалению через `document` мы не можем обратиться к конкретному элементу документа напрямую. для этого есть ряд методов, который позволяют отбирать элементы документа по некоторым правилам. Важно! Долгое время основным инструментом для взаимодействия с DOM была библиотека [jQuery](https://jquery.com/), сейчас пик ее славы пройден, днако в некоторых проектах ее применение все еще может быть оправдано. В плане краткого справочника по JS и манипуляции DOM стоит ознакомиться вот с [этим](https://www.w3schools.com/js/default.asp).

```javascript

// получение элемента по id
// возвращает единственный элемент с id root
var element = document.getElementById('root');

// получение элементов по css классу
var elements = document.getElementsByClassName('list-item');

// получение элементов по имени тега
var divs = document.getElementsByTagName('div');

// получает элемент удовлетворяющий правилу
var queryResult = document.querySelector('#root .items .item');

// получает все элементы удовлетворяющие правилу
var queryResults = document.querySelectorAll('#root .items .item');

// также можно использовать контекст поиска
// поиск элементов внутри элемента с id root
var contextResult = element.querySelectorAll('.items');

// изменение параметров
element.style.backgroundColor='#fffeee' // к свойствам которые в css именуются в kebab-case в js обращаются в camelCase

// добавление/удаление классов

element.classList.add("class-name") // добавляем класс.
element.classList.remove("class-name") // удаляем класс.
element.classList.toggle("class-name") // если такого класса нет добавляем иначе удаляем

// манипулирование DOM деревом
var newElement = document.createElement('tagName') // создает в памяти элемент с тегом tagName
document.removeChild(element) // удаляет элемент
document.appendChild(element) // добавляет в DOM дерево элемент
document.replaceChild(new, old) // замена элементов.



/* Подписка на события */
// есть несколько способов подписаться на события, однако, 
// наиболее распростаненеый воспользоваться addEventListener

// тут про root если что
element.addEventListener('click', function(e) { // click имя события
    console.log(e); // callback функция обрабатывающая это события
    // e - контейнер сообщения.
});

```

BOM - browser object model (объектная модель браузера) предоставляет API для взаимодействия с браузером пользователя. Подробнее [здесь](https://www.w3schools.com/js/js_window.asp)

## **ES6, Babel, Webpack**

**ES6** - обновленная спецификкация JavaScript, которая на данный момент не понятно es6 или es7 или es8..в общем надо гуглить, много гуглить. Суть новый JS вкльчает в себя много всяких сахарных плюшек, но есть одна очень важная вешь это подержка нового формата модулей, ага он не один и все каким-то образом умудряются работать, есть модули ES6 и AMD.

Модули используются для описания зависимостей частей кода внутри проекта, которые потом разрешаются на сервере сервером на фронте webpack, при этом на фронте используется своя парадигма применения модулей.

```javascript
/* оформляем в модуль множество функций и значений */
/* для дальнейшего использования как единого объекта */

const message = 'Hello';
function hello() {
    console.log(message);
}

export default {
    message,
    hello
}

/* используем этот модуль в другом файле*/
import person from 'path-to-file'

console.log(person.message);
person.hello();

/* можно и подругому */

const message = 'Hello';
function hello() {
    console.log(message);
}

export { //без default экспортируется не объект а список элементов
    message,
    hello
}


/* используем этот модуль в другом файле*/
// в фигурных скобках указываем, что должно быть загружено
// имя объекта as "some-text" - алиас для загружаемого объекта
import { hello, message as helloMesssage} from 'path-to-file' 

console.log(helloMesssage);
hello();

```
Чуть подробнее об [import](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import).
Чуть подробнее об [export](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export)

**Babel** - в силу того, что самые новые спецификации не поддерживаются браузерами придумали инструмент, который переводит код, написанный на новом JS в старый, имя этому инструменту [babel](https://babeljs.io/)

**Webpack** - в силу того что, самые новые спецификации не поддерживаются браузерами, а так же нет никакой возможности указывать зависимости для кусков кода JS использемого на клиенте был разработан [wepback](https://webpack.js.org/), краткий гайд по конфигурации [здесь](https://webpack.js.org/guides/). Конфигурация вебпака, удовольствие сомнительное, да и как решение он так себе но конкурентную борьбу он, к сожалению выиграл...

## **Package.json**

Поскольку JS нынче больше, чем просто скриптовый язык для реализации плюшек в браузере, у него есть своя экосистема и набор инструментария для создания проекта на JS. Одним из важнейших элементов экосистемы является утилита командной строки `npm`.

Команда `npm init` - инициирует процедуру создания файла `package.json`, но никто не не запрещает вам просто создать файл `package.json`  и описать все вручную, главное следовать правилам описания JSON и структуре.

Структура `package.json`

```JSON
{
    "name": "project-name", // крайне желательно указывать.
    "version": "0.0.1", // версия указывается в формате semver https://docs.npmjs.com/misc/semver
    "description": "Project description", // краткое описание проекта
    "author": "Your name", // автор проекта,
    "license": "Licence", // сведения о лицензии
    "repository": { //сведения о репозитории
        "type": "git", // тип системы контроля версий
        "url": "path to remote git repository" // адрес репозитория
    },
    "main":"path-to-js-file", // путь к фалу который является точкой 
    //входа именно этот фал будет подгружаться при импорте
    "scripts": { // список команд, которые запускаются на различных этапах // жизненного цикла проекта запускаются npm run commandName
        "commandName": "command body",
        "commandName2": "command body2",
    },

    "dependencies": { // список зависимостей вашего проекта без
                     // которых он работать не будет
        "packageName1": "version in semver",
        "packageName2": "version in semver"
    },

    "devDependencies": { // список зависимостей  необходимых для разработки
        "packageName1": "version in semver",
        "packageName2": "version in semver"
    }
}

```
Приведенное выше описание не полное, но как правило достаточное для описания проекта, полный список параметров `package.json` смотрим [тут](https://docs.npmjs.com/files/package.json). 

Подробнее о секцииях `dependencies` `devDependencies`. Как было написано выше `dependencies` это список пакетов которые требуются для работы вашего проекта. Для установки пакета необходимо выполнить команду `npm install package-name --save` это инициируетзагрузку пакета из репозитория npm в папку `node_modules` в папку проекта, а в секцию `dependencies` будет добавлена запись о зависимости. Для удаления пакета необходимо выполнить команду `npm uninstall package-name --save`  Для установки пакета и записи  сведений о нем в секции `devDependencies` необходимо выполнить команду `npm install package-name --save-dev`. Для чего нужна секция `devDependencies`? Для обеспечение инфраструктуры разработки. Предположим, что вы разрабатываете библиотеку для клиентской части, вам, как разработчику, нужно иметь возможность посмотреть результат работы во время разработки, для этого вы поднимаете у себя локальный сервер. Нужны ли конечному пользователю вашей библиотеки пакеты, используемые вами для разработки и тестирования? Нет ему нужен конечный результат. Именно для этого и существует такое разделение. Описание пакетов в `package.json` дает разработчику представление о зависимостях, а так же позволяет, допустим его коллеге попыстрому установить необходимые библиотеки к себе на компьютер, выполнив команду `npm install`.

> **Задание 1**
>
>В паке `src` создайте папку `hedgehog-modules`, в ней создайте файл `scroll-top.js` в этом файле опишите модуль который обеспечивает плавную прокрутку к верху странице. Должен быть обработчик клика по элементу и реализация прокрутки. Элемент плавной прокрутке должен быть виден, только когда пользователь прокрутил страницу на 100 пикселей. Оформите это в виде модуля. Подключите этот модуль в файле `hedgehog.js`. В `hedgehog.html` добавьте разметку элемента, который будет инициализировать плавную прокрутку. Стили для элемента прокрутки разместите в папке `hedgehog-modules`


> **Задание 2**
>
>Добавьте в ежиный чат жизни. При отправке сообщения чат должен пополняться новым сообщением от имени волка. Также оформить в модуль. 




